# [allow (unused_imports)] pub use progenitor_client :: { ByteStream , Error , ResponseValue } ; # [allow (unused_imports)] use progenitor_client :: { encode_path , RequestBuilderExt } ; # [allow (unused_imports)] use reqwest :: header :: { HeaderMap , HeaderValue } ; # [doc = r" Types used as operation parameters and responses."] # [allow (clippy :: all)] pub mod types { # [doc = r" Error types."] pub mod error { # [doc = r" Error from a TryFrom or FromStr implementation."] pub struct ConversionError (:: std :: borrow :: Cow < 'static , str >) ; impl :: std :: error :: Error for ConversionError { } impl :: std :: fmt :: Display for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Display :: fmt (& self . 0 , f) } } impl :: std :: fmt :: Debug for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Debug :: fmt (& self . 0 , f) } } impl From < & 'static str > for ConversionError { fn from (value : & 'static str) -> Self { Self (value . into ()) } } impl From < String > for ConversionError { fn from (value : String) -> Self { Self (value . into ()) } } } # [doc = "AbortQueryJobBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"state\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"state\": {"] # [doc = "      \"description\": \"Must be set to \\\"Aborted\\\" to abort the job\","] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"Aborted\""] # [doc = "      ]"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct AbortQueryJobBody { # [doc = "Must be set to \"Aborted\" to abort the job"] pub state : AbortQueryJobBodyState , } impl From < & AbortQueryJobBody > for AbortQueryJobBody { fn from (value : & AbortQueryJobBody) -> Self { value . clone () } } # [doc = "Must be set to \"Aborted\" to abort the job"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Must be set to \\\"Aborted\\\" to abort the job\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Aborted\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum AbortQueryJobBodyState { Aborted , } impl From < & AbortQueryJobBodyState > for AbortQueryJobBodyState { fn from (value : & AbortQueryJobBodyState) -> Self { value . clone () } } impl :: std :: fmt :: Display for AbortQueryJobBodyState { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Aborted => write ! (f , "Aborted") , } } } impl std :: str :: FromStr for AbortQueryJobBodyState { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "Aborted" => Ok (Self :: Aborted) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for AbortQueryJobBodyState { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for AbortQueryJobBodyState { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for AbortQueryJobBodyState { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "CSV column delimiter"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"CSV column delimiter\","] # [doc = "  \"default\": \"COMMA\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"BACKQUOTE\","] # [doc = "    \"CARET\","] # [doc = "    \"COMMA\","] # [doc = "    \"PIPE\","] # [doc = "    \"SEMICOLON\","] # [doc = "    \"TAB\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ColumnDelimiter { # [serde (rename = "BACKQUOTE")] Backquote , # [serde (rename = "CARET")] Caret , # [serde (rename = "COMMA")] Comma , # [serde (rename = "PIPE")] Pipe , # [serde (rename = "SEMICOLON")] Semicolon , # [serde (rename = "TAB")] Tab , } impl From < & ColumnDelimiter > for ColumnDelimiter { fn from (value : & ColumnDelimiter) -> Self { value . clone () } } impl :: std :: fmt :: Display for ColumnDelimiter { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Backquote => write ! (f , "BACKQUOTE") , Self :: Caret => write ! (f , "CARET") , Self :: Comma => write ! (f , "COMMA") , Self :: Pipe => write ! (f , "PIPE") , Self :: Semicolon => write ! (f , "SEMICOLON") , Self :: Tab => write ! (f , "TAB") , } } } impl std :: str :: FromStr for ColumnDelimiter { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "BACKQUOTE" => Ok (Self :: Backquote) , "CARET" => Ok (Self :: Caret) , "COMMA" => Ok (Self :: Comma) , "PIPE" => Ok (Self :: Pipe) , "SEMICOLON" => Ok (Self :: Semicolon) , "TAB" => Ok (Self :: Tab) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for ColumnDelimiter { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for ColumnDelimiter { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for ColumnDelimiter { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for ColumnDelimiter { fn default () -> Self { ColumnDelimiter :: Comma } } # [doc = "Job processing concurrency mode"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Job processing concurrency mode\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Parallel\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ConcurrencyMode { Parallel , } impl From < & ConcurrencyMode > for ConcurrencyMode { fn from (value : & ConcurrencyMode) -> Self { value . clone () } } impl :: std :: fmt :: Display for ConcurrencyMode { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Parallel => write ! (f , "Parallel") , } } } impl std :: str :: FromStr for ConcurrencyMode { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "Parallel" => Ok (Self :: Parallel) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for ConcurrencyMode { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for ConcurrencyMode { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for ConcurrencyMode { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Format of the data"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Format of the data\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"CSV\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum ContentType { # [serde (rename = "CSV")] Csv , } impl From < & ContentType > for ContentType { fn from (value : & ContentType) -> Self { value . clone () } } impl :: std :: fmt :: Display for ContentType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Csv => write ! (f , "CSV") , } } } impl std :: str :: FromStr for ContentType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "CSV" => Ok (Self :: Csv) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for ContentType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for ContentType { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for ContentType { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "CreateIngestJobRequest"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"object\","] # [doc = "    \"operation\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"assignmentRuleId\": {"] # [doc = "      \"description\": \"Assignment rule ID for Cases or Leads\","] # [doc = "      \"examples\": ["] # [doc = "        \"01Qxx000000000FEAQ\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"columnDelimiter\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ColumnDelimiter\""] # [doc = "    },"] # [doc = "    \"contentType\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ContentType\""] # [doc = "    },"] # [doc = "    \"externalIdFieldName\": {"] # [doc = "      \"description\": \"External ID field name (required for upsert operations)\","] # [doc = "      \"examples\": ["] # [doc = "        \"ExternalId__c\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"lineEnding\": {"] # [doc = "      \"$ref\": \"#/components/schemas/LineEnding\""] # [doc = "    },"] # [doc = "    \"object\": {"] # [doc = "      \"description\": \"Salesforce object API name\","] # [doc = "      \"examples\": ["] # [doc = "        \"Account\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"operation\": {"] # [doc = "      \"$ref\": \"#/components/schemas/IngestOperation\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct CreateIngestJobRequest { # [doc = "Assignment rule ID for Cases or Leads"] # [serde (rename = "assignmentRuleId" , default , skip_serializing_if = "Option::is_none")] pub assignment_rule_id : Option < String > , # [serde (rename = "columnDelimiter" , default , skip_serializing_if = "Option::is_none")] pub column_delimiter : Option < ColumnDelimiter > , # [serde (rename = "contentType" , default , skip_serializing_if = "Option::is_none")] pub content_type : Option < ContentType > , # [doc = "External ID field name (required for upsert operations)"] # [serde (rename = "externalIdFieldName" , default , skip_serializing_if = "Option::is_none")] pub external_id_field_name : Option < String > , # [serde (rename = "lineEnding" , default , skip_serializing_if = "Option::is_none")] pub line_ending : Option < LineEnding > , # [doc = "Salesforce object API name"] pub object : String , pub operation : IngestOperation , } impl From < & CreateIngestJobRequest > for CreateIngestJobRequest { fn from (value : & CreateIngestJobRequest) -> Self { value . clone () } } # [doc = "CreateQueryJobRequest"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"operation\","] # [doc = "    \"query\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"columnDelimiter\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ColumnDelimiter\""] # [doc = "    },"] # [doc = "    \"contentType\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ContentType\""] # [doc = "    },"] # [doc = "    \"lineEnding\": {"] # [doc = "      \"$ref\": \"#/components/schemas/LineEnding\""] # [doc = "    },"] # [doc = "    \"operation\": {"] # [doc = "      \"$ref\": \"#/components/schemas/QueryOperation\""] # [doc = "    },"] # [doc = "    \"query\": {"] # [doc = "      \"description\": \"SOQL query string to execute\","] # [doc = "      \"examples\": ["] # [doc = "        \"SELECT Id, Name FROM Account WHERE Industry = 'Technology'\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct CreateQueryJobRequest { # [serde (rename = "columnDelimiter" , default , skip_serializing_if = "Option::is_none")] pub column_delimiter : Option < ColumnDelimiter > , # [serde (rename = "contentType" , default , skip_serializing_if = "Option::is_none")] pub content_type : Option < ContentType > , # [serde (rename = "lineEnding" , default , skip_serializing_if = "Option::is_none")] pub line_ending : Option < LineEnding > , pub operation : QueryOperation , # [doc = "SOQL query string to execute"] pub query : String , } impl From < & CreateQueryJobRequest > for CreateQueryJobRequest { fn from (value : & CreateQueryJobRequest) -> Self { value . clone () } } # [doc = "Error"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"errorCode\","] # [doc = "    \"message\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"errorCode\": {"] # [doc = "      \"description\": \"Error code identifier\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"message\": {"] # [doc = "      \"description\": \"Descriptive error message\","] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct Error { # [doc = "Error code identifier"] # [serde (rename = "errorCode")] pub error_code : String , # [doc = "Descriptive error message"] pub message : String , } impl From < & Error > for Error { fn from (value : & Error) -> Self { value . clone () } } # [doc = "ErrorResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"array\","] # [doc = "  \"items\": {"] # [doc = "    \"$ref\": \"#/components/schemas/Error\""] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct ErrorResponse (pub Vec < Error >) ; impl :: std :: ops :: Deref for ErrorResponse { type Target = Vec < Error > ; fn deref (& self) -> & Vec < Error > { & self . 0 } } impl From < ErrorResponse > for Vec < Error > { fn from (value : ErrorResponse) -> Self { value . 0 } } impl From < & ErrorResponse > for ErrorResponse { fn from (value : & ErrorResponse) -> Self { value . clone () } } impl From < Vec < Error > > for ErrorResponse { fn from (value : Vec < Error >) -> Self { Self (value) } } # [doc = "GetAllIngestJobsResponse"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"done\","] # [doc = "    \"records\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"done\": {"] # [doc = "      \"description\": \"Whether there are more jobs beyond this page\","] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"nextRecordsUrl\": {"] # [doc = "      \"description\": \"URL to retrieve the next page of results\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"records\": {"] # [doc = "      \"description\": \"List of ingest jobs\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"$ref\": \"#/components/schemas/IngestJobInfo\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct GetAllIngestJobsResponse { # [doc = "Whether there are more jobs beyond this page"] pub done : bool , # [doc = "URL to retrieve the next page of results"] # [serde (rename = "nextRecordsUrl" , default , skip_serializing_if = "Option::is_none")] pub next_records_url : Option < String > , # [doc = "List of ingest jobs"] pub records : Vec < IngestJobInfo > , } impl From < & GetAllIngestJobsResponse > for GetAllIngestJobsResponse { fn from (value : & GetAllIngestJobsResponse) -> Self { value . clone () } } # [doc = "IngestJobInfo"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"apiVersion\","] # [doc = "    \"concurrencyMode\","] # [doc = "    \"contentType\","] # [doc = "    \"createdById\","] # [doc = "    \"createdDate\","] # [doc = "    \"id\","] # [doc = "    \"object\","] # [doc = "    \"operation\","] # [doc = "    \"state\","] # [doc = "    \"systemModstamp\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"apexProcessingTime\": {"] # [doc = "      \"description\": \"Apex trigger/workflow time in milliseconds\","] # [doc = "      \"examples\": ["] # [doc = "        3100"] # [doc = "      ],"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"apiActiveProcessingTime\": {"] # [doc = "      \"description\": \"API processing time in milliseconds\","] # [doc = "      \"examples\": ["] # [doc = "        8200"] # [doc = "      ],"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"apiVersion\": {"] # [doc = "      \"description\": \"API version used for the job\","] # [doc = "      \"examples\": ["] # [doc = "        65.0"] # [doc = "      ],"] # [doc = "      \"type\": \"number\","] # [doc = "      \"format\": \"float\""] # [doc = "    },"] # [doc = "    \"assignmentRuleId\": {"] # [doc = "      \"description\": \"The ID of an assignment rule for Cases or Leads\","] # [doc = "      \"examples\": ["] # [doc = "        \"01Qxx000000000FEAQ\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"columnDelimiter\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ColumnDelimiter\""] # [doc = "    },"] # [doc = "    \"concurrencyMode\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ConcurrencyMode\""] # [doc = "    },"] # [doc = "    \"contentType\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ContentType\""] # [doc = "    },"] # [doc = "    \"contentUrl\": {"] # [doc = "      \"description\": \"Relative URL to upload data\","] # [doc = "      \"examples\": ["] # [doc = "        \"services/data/v65.0/jobs/ingest/750xx0000000002AAA/batches\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"createdById\": {"] # [doc = "      \"description\": \"User ID who created the job\","] # [doc = "      \"examples\": ["] # [doc = "        \"005xx000000000FAAQ\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"createdDate\": {"] # [doc = "      \"description\": \"Job creation timestamp in ISO 8601 format\","] # [doc = "      \"examples\": ["] # [doc = "        \"2024-01-15T10:30:00.000Z\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"errorMessage\": {"] # [doc = "      \"description\": \"Error message for jobs with errors\","] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"externalIdFieldName\": {"] # [doc = "      \"description\": \"External ID field name (if specified for upsert)\","] # [doc = "      \"examples\": ["] # [doc = "        \"ExternalId__c\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"description\": \"Unique job identifier (18-character Salesforce ID)\","] # [doc = "      \"examples\": ["] # [doc = "        \"750xx0000000002AAA\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"jobType\": {"] # [doc = "      \"$ref\": \"#/components/schemas/JobType\""] # [doc = "    },"] # [doc = "    \"lineEnding\": {"] # [doc = "      \"$ref\": \"#/components/schemas/LineEnding\""] # [doc = "    },"] # [doc = "    \"numberRecordsFailed\": {"] # [doc = "      \"description\": \"Number of records that failed\","] # [doc = "      \"examples\": ["] # [doc = "        10"] # [doc = "      ],"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"numberRecordsProcessed\": {"] # [doc = "      \"description\": \"Number of records processed\","] # [doc = "      \"examples\": ["] # [doc = "        5000"] # [doc = "      ],"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"object\": {"] # [doc = "      \"description\": \"Salesforce object API name\","] # [doc = "      \"examples\": ["] # [doc = "        \"Account\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"operation\": {"] # [doc = "      \"$ref\": \"#/components/schemas/IngestOperation\""] # [doc = "    },"] # [doc = "    \"retries\": {"] # [doc = "      \"description\": \"Number of retry attempts\","] # [doc = "      \"examples\": ["] # [doc = "        0"] # [doc = "      ],"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"state\": {"] # [doc = "      \"$ref\": \"#/components/schemas/JobState\""] # [doc = "    },"] # [doc = "    \"systemModstamp\": {"] # [doc = "      \"description\": \"Last modified timestamp in ISO 8601 format\","] # [doc = "      \"examples\": ["] # [doc = "        \"2024-01-15T10:30:00.000Z\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"totalProcessingTime\": {"] # [doc = "      \"description\": \"Total processing time in milliseconds\","] # [doc = "      \"examples\": ["] # [doc = "        12500"] # [doc = "      ],"] # [doc = "      \"type\": \"integer\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct IngestJobInfo { # [doc = "Apex trigger/workflow time in milliseconds"] # [serde (rename = "apexProcessingTime" , default , skip_serializing_if = "Option::is_none")] pub apex_processing_time : Option < i64 > , # [doc = "API processing time in milliseconds"] # [serde (rename = "apiActiveProcessingTime" , default , skip_serializing_if = "Option::is_none")] pub api_active_processing_time : Option < i64 > , # [serde (rename = "apiVersion")] pub api_version : f32 , # [doc = "The ID of an assignment rule for Cases or Leads"] # [serde (rename = "assignmentRuleId" , default , skip_serializing_if = "Option::is_none")] pub assignment_rule_id : Option < String > , # [serde (rename = "columnDelimiter" , default , skip_serializing_if = "Option::is_none")] pub column_delimiter : Option < ColumnDelimiter > , # [serde (rename = "concurrencyMode")] pub concurrency_mode : ConcurrencyMode , # [serde (rename = "contentType")] pub content_type : ContentType , # [doc = "Relative URL to upload data"] # [serde (rename = "contentUrl" , default , skip_serializing_if = "Option::is_none")] pub content_url : Option < String > , # [doc = "User ID who created the job"] # [serde (rename = "createdById")] pub created_by_id : String , # [doc = "Job creation timestamp in ISO 8601 format"] # [serde (rename = "createdDate")] pub created_date : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Error message for jobs with errors"] # [serde (rename = "errorMessage" , default , skip_serializing_if = "Option::is_none")] pub error_message : Option < String > , # [doc = "External ID field name (if specified for upsert)"] # [serde (rename = "externalIdFieldName" , default , skip_serializing_if = "Option::is_none")] pub external_id_field_name : Option < String > , # [doc = "Unique job identifier (18-character Salesforce ID)"] pub id : String , # [serde (rename = "jobType" , default , skip_serializing_if = "Option::is_none")] pub job_type : Option < JobType > , # [serde (rename = "lineEnding" , default , skip_serializing_if = "Option::is_none")] pub line_ending : Option < LineEnding > , # [doc = "Number of records that failed"] # [serde (rename = "numberRecordsFailed" , default , skip_serializing_if = "Option::is_none")] pub number_records_failed : Option < i64 > , # [doc = "Number of records processed"] # [serde (rename = "numberRecordsProcessed" , default , skip_serializing_if = "Option::is_none")] pub number_records_processed : Option < i64 > , # [doc = "Salesforce object API name"] pub object : String , pub operation : IngestOperation , # [doc = "Number of retry attempts"] # [serde (default , skip_serializing_if = "Option::is_none")] pub retries : Option < i64 > , pub state : JobState , # [doc = "Last modified timestamp in ISO 8601 format"] # [serde (rename = "systemModstamp")] pub system_modstamp : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Total processing time in milliseconds"] # [serde (rename = "totalProcessingTime" , default , skip_serializing_if = "Option::is_none")] pub total_processing_time : Option < i64 > , } impl From < & IngestJobInfo > for IngestJobInfo { fn from (value : & IngestJobInfo) -> Self { value . clone () } } # [doc = "Type of ingest operation"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Type of ingest operation\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"insert\","] # [doc = "    \"update\","] # [doc = "    \"upsert\","] # [doc = "    \"delete\","] # [doc = "    \"hardDelete\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum IngestOperation { # [serde (rename = "insert")] Insert , # [serde (rename = "update")] Update , # [serde (rename = "upsert")] Upsert , # [serde (rename = "delete")] Delete , # [serde (rename = "hardDelete")] HardDelete , } impl From < & IngestOperation > for IngestOperation { fn from (value : & IngestOperation) -> Self { value . clone () } } impl :: std :: fmt :: Display for IngestOperation { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Insert => write ! (f , "insert") , Self :: Update => write ! (f , "update") , Self :: Upsert => write ! (f , "upsert") , Self :: Delete => write ! (f , "delete") , Self :: HardDelete => write ! (f , "hardDelete") , } } } impl std :: str :: FromStr for IngestOperation { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "insert" => Ok (Self :: Insert) , "update" => Ok (Self :: Update) , "upsert" => Ok (Self :: Upsert) , "delete" => Ok (Self :: Delete) , "hardDelete" => Ok (Self :: HardDelete) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for IngestOperation { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for IngestOperation { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for IngestOperation { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Current state of the job"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Current state of the job\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"Open\","] # [doc = "    \"UploadComplete\","] # [doc = "    \"InProgress\","] # [doc = "    \"JobComplete\","] # [doc = "    \"Failed\","] # [doc = "    \"Aborted\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum JobState { Open , UploadComplete , InProgress , JobComplete , Failed , Aborted , } impl From < & JobState > for JobState { fn from (value : & JobState) -> Self { value . clone () } } impl :: std :: fmt :: Display for JobState { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Open => write ! (f , "Open") , Self :: UploadComplete => write ! (f , "UploadComplete") , Self :: InProgress => write ! (f , "InProgress") , Self :: JobComplete => write ! (f , "JobComplete") , Self :: Failed => write ! (f , "Failed") , Self :: Aborted => write ! (f , "Aborted") , } } } impl std :: str :: FromStr for JobState { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "Open" => Ok (Self :: Open) , "UploadComplete" => Ok (Self :: UploadComplete) , "InProgress" => Ok (Self :: InProgress) , "JobComplete" => Ok (Self :: JobComplete) , "Failed" => Ok (Self :: Failed) , "Aborted" => Ok (Self :: Aborted) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for JobState { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for JobState { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for JobState { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Type of bulk job"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Type of bulk job\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"V2Query\","] # [doc = "    \"V2Ingest\","] # [doc = "    \"BigObjectIngest\","] # [doc = "    \"Classic\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum JobType { V2Query , V2Ingest , BigObjectIngest , Classic , } impl From < & JobType > for JobType { fn from (value : & JobType) -> Self { value . clone () } } impl :: std :: fmt :: Display for JobType { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: V2Query => write ! (f , "V2Query") , Self :: V2Ingest => write ! (f , "V2Ingest") , Self :: BigObjectIngest => write ! (f , "BigObjectIngest") , Self :: Classic => write ! (f , "Classic") , } } } impl std :: str :: FromStr for JobType { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "V2Query" => Ok (Self :: V2Query) , "V2Ingest" => Ok (Self :: V2Ingest) , "BigObjectIngest" => Ok (Self :: BigObjectIngest) , "Classic" => Ok (Self :: Classic) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for JobType { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for JobType { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for JobType { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "Line ending format"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Line ending format\","] # [doc = "  \"default\": \"LF\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"LF\","] # [doc = "    \"CRLF\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum LineEnding { # [serde (rename = "LF")] Lf , # [serde (rename = "CRLF")] Crlf , } impl From < & LineEnding > for LineEnding { fn from (value : & LineEnding) -> Self { value . clone () } } impl :: std :: fmt :: Display for LineEnding { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Lf => write ! (f , "LF") , Self :: Crlf => write ! (f , "CRLF") , } } } impl std :: str :: FromStr for LineEnding { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "LF" => Ok (Self :: Lf) , "CRLF" => Ok (Self :: Crlf) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for LineEnding { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for LineEnding { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for LineEnding { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl Default for LineEnding { fn default () -> Self { LineEnding :: Lf } } # [doc = "QueryJobInfo"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"apiVersion\","] # [doc = "    \"concurrencyMode\","] # [doc = "    \"contentType\","] # [doc = "    \"createdById\","] # [doc = "    \"createdDate\","] # [doc = "    \"id\","] # [doc = "    \"object\","] # [doc = "    \"operation\","] # [doc = "    \"state\","] # [doc = "    \"systemModstamp\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"apiVersion\": {"] # [doc = "      \"description\": \"API version used for the job\","] # [doc = "      \"examples\": ["] # [doc = "        65.0"] # [doc = "      ],"] # [doc = "      \"type\": \"number\","] # [doc = "      \"format\": \"float\""] # [doc = "    },"] # [doc = "    \"columnDelimiter\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ColumnDelimiter\""] # [doc = "    },"] # [doc = "    \"concurrencyMode\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ConcurrencyMode\""] # [doc = "    },"] # [doc = "    \"contentType\": {"] # [doc = "      \"$ref\": \"#/components/schemas/ContentType\""] # [doc = "    },"] # [doc = "    \"createdById\": {"] # [doc = "      \"description\": \"User ID who created the job\","] # [doc = "      \"examples\": ["] # [doc = "        \"005xx000000000FAAQ\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"createdDate\": {"] # [doc = "      \"description\": \"Job creation timestamp in ISO 8601 format\","] # [doc = "      \"examples\": ["] # [doc = "        \"2024-01-15T10:30:00.000Z\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"id\": {"] # [doc = "      \"description\": \"Unique job identifier (18-character Salesforce ID)\","] # [doc = "      \"examples\": ["] # [doc = "        \"750xx0000000001AAA\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"isPkChunkingSupported\": {"] # [doc = "      \"description\": \"Whether PK chunking is supported for the queried object\","] # [doc = "      \"examples\": ["] # [doc = "        true"] # [doc = "      ],"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"jobType\": {"] # [doc = "      \"$ref\": \"#/components/schemas/JobType\""] # [doc = "    },"] # [doc = "    \"lineEnding\": {"] # [doc = "      \"$ref\": \"#/components/schemas/LineEnding\""] # [doc = "    },"] # [doc = "    \"numberRecordsProcessed\": {"] # [doc = "      \"description\": \"Number of records processed (only present after job completion)\","] # [doc = "      \"examples\": ["] # [doc = "        1000"] # [doc = "      ],"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"object\": {"] # [doc = "      \"description\": \"Salesforce object being queried (derived from SOQL)\","] # [doc = "      \"examples\": ["] # [doc = "        \"Account\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"operation\": {"] # [doc = "      \"$ref\": \"#/components/schemas/QueryOperation\""] # [doc = "    },"] # [doc = "    \"retries\": {"] # [doc = "      \"description\": \"Number of retry attempts\","] # [doc = "      \"examples\": ["] # [doc = "        0"] # [doc = "      ],"] # [doc = "      \"type\": \"integer\""] # [doc = "    },"] # [doc = "    \"state\": {"] # [doc = "      \"$ref\": \"#/components/schemas/JobState\""] # [doc = "    },"] # [doc = "    \"systemModstamp\": {"] # [doc = "      \"description\": \"Last modified timestamp in ISO 8601 format\","] # [doc = "      \"examples\": ["] # [doc = "        \"2024-01-15T10:30:00.000Z\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\","] # [doc = "      \"format\": \"date-time\""] # [doc = "    },"] # [doc = "    \"totalProcessingTime\": {"] # [doc = "      \"description\": \"Total processing time in milliseconds\","] # [doc = "      \"examples\": ["] # [doc = "        249"] # [doc = "      ],"] # [doc = "      \"type\": \"integer\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct QueryJobInfo { # [serde (rename = "apiVersion")] pub api_version : f32 , # [serde (rename = "columnDelimiter" , default , skip_serializing_if = "Option::is_none")] pub column_delimiter : Option < ColumnDelimiter > , # [serde (rename = "concurrencyMode")] pub concurrency_mode : ConcurrencyMode , # [serde (rename = "contentType")] pub content_type : ContentType , # [doc = "User ID who created the job"] # [serde (rename = "createdById")] pub created_by_id : String , # [doc = "Job creation timestamp in ISO 8601 format"] # [serde (rename = "createdDate")] pub created_date : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Unique job identifier (18-character Salesforce ID)"] pub id : String , # [doc = "Whether PK chunking is supported for the queried object"] # [serde (rename = "isPkChunkingSupported" , default , skip_serializing_if = "Option::is_none")] pub is_pk_chunking_supported : Option < bool > , # [serde (rename = "jobType" , default , skip_serializing_if = "Option::is_none")] pub job_type : Option < JobType > , # [serde (rename = "lineEnding" , default , skip_serializing_if = "Option::is_none")] pub line_ending : Option < LineEnding > , # [doc = "Number of records processed (only present after job completion)"] # [serde (rename = "numberRecordsProcessed" , default , skip_serializing_if = "Option::is_none")] pub number_records_processed : Option < i64 > , # [doc = "Salesforce object being queried (derived from SOQL)"] pub object : String , pub operation : QueryOperation , # [doc = "Number of retry attempts"] # [serde (default , skip_serializing_if = "Option::is_none")] pub retries : Option < i64 > , pub state : JobState , # [doc = "Last modified timestamp in ISO 8601 format"] # [serde (rename = "systemModstamp")] pub system_modstamp : chrono :: DateTime < chrono :: offset :: Utc > , # [doc = "Total processing time in milliseconds"] # [serde (rename = "totalProcessingTime" , default , skip_serializing_if = "Option::is_none")] pub total_processing_time : Option < i64 > , } impl From < & QueryJobInfo > for QueryJobInfo { fn from (value : & QueryJobInfo) -> Self { value . clone () } } # [doc = "QueryJobList"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"done\","] # [doc = "    \"records\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"done\": {"] # [doc = "      \"description\": \"Whether there are more records beyond this page\","] # [doc = "      \"examples\": ["] # [doc = "        true"] # [doc = "      ],"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"nextRecordsUrl\": {"] # [doc = "      \"description\": \"URL to retrieve the next page of results (if done is false)\","] # [doc = "      \"examples\": ["] # [doc = "        \"/services/data/v65.0/jobs/query?locator=xxx\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"records\": {"] # [doc = "      \"description\": \"List of query jobs\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"$ref\": \"#/components/schemas/QueryJobInfo\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct QueryJobList { # [doc = "Whether there are more records beyond this page"] pub done : bool , # [doc = "URL to retrieve the next page of results (if done is false)"] # [serde (rename = "nextRecordsUrl" , default , skip_serializing_if = "Option::is_none")] pub next_records_url : Option < String > , # [doc = "List of query jobs"] pub records : Vec < QueryJobInfo > , } impl From < & QueryJobList > for QueryJobList { fn from (value : & QueryJobList) -> Self { value . clone () } } # [doc = "Type of query operation"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"description\": \"Type of query operation\","] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"query\","] # [doc = "    \"queryAll\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum QueryOperation { # [serde (rename = "query")] Query , # [serde (rename = "queryAll")] QueryAll , } impl From < & QueryOperation > for QueryOperation { fn from (value : & QueryOperation) -> Self { value . clone () } } impl :: std :: fmt :: Display for QueryOperation { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Query => write ! (f , "query") , Self :: QueryAll => write ! (f , "queryAll") , } } } impl std :: str :: FromStr for QueryOperation { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> Result < Self , self :: error :: ConversionError > { match value { "query" => Ok (Self :: Query) , "queryAll" => Ok (Self :: QueryAll) , _ => Err ("invalid value" . into ()) , } } } impl std :: convert :: TryFrom < & str > for QueryOperation { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < & String > for QueryOperation { type Error = self :: error :: ConversionError ; fn try_from (value : & String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } impl std :: convert :: TryFrom < String > for QueryOperation { type Error = self :: error :: ConversionError ; fn try_from (value : String) -> Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "QueryResultPage"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"resultUrl\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"resultUrl\": {"] # [doc = "      \"description\": \"The request URI with the locator for getting data\","] # [doc = "      \"examples\": ["] # [doc = "        \"/services/data/v65.0/jobs/query/750R0000000zxr8IAA/results?locator=aBcDeFg4N\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct QueryResultPage { # [doc = "The request URI with the locator for getting data"] # [serde (rename = "resultUrl")] pub result_url : String , } impl From < & QueryResultPage > for QueryResultPage { fn from (value : & QueryResultPage) -> Self { value . clone () } } # [doc = "QueryResultPages"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"done\","] # [doc = "    \"resultPages\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"done\": {"] # [doc = "      \"description\": \"A Boolean value that indicates whether more resultUrl URIs are available\","] # [doc = "      \"examples\": ["] # [doc = "        false"] # [doc = "      ],"] # [doc = "      \"type\": \"boolean\""] # [doc = "    },"] # [doc = "    \"nextRecordsUrl\": {"] # [doc = "      \"description\": \"The URI used to get the next set of resultPages\","] # [doc = "      \"examples\": ["] # [doc = "        \"/services/data/v65.0/jobs/query/750R0000000zxr8IAA/resultPages?locator=YcApWm4N\""] # [doc = "      ],"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"resultPages\": {"] # [doc = "      \"description\": \"Contains the resultUrl URIs (up to 5 per response)\","] # [doc = "      \"type\": \"array\","] # [doc = "      \"items\": {"] # [doc = "        \"$ref\": \"#/components/schemas/QueryResultPage\""] # [doc = "      }"] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct QueryResultPages { # [doc = "A Boolean value that indicates whether more resultUrl URIs are available"] pub done : bool , # [doc = "The URI used to get the next set of resultPages"] # [serde (rename = "nextRecordsUrl" , default , skip_serializing_if = "Option::is_none")] pub next_records_url : Option < String > , # [doc = "Contains the resultUrl URIs (up to 5 per response)"] # [serde (rename = "resultPages")] pub result_pages : Vec < QueryResultPage > , } impl From < & QueryResultPages > for QueryResultPages { fn from (value : & QueryResultPages) -> Self { value . clone () } } # [doc = "UpdateIngestJobStateBody"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"state\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"state\": {"] # [doc = "      \"$ref\": \"#/components/schemas/JobState\""] # [doc = "    }"] # [doc = "  }"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] pub struct UpdateIngestJobStateBody { pub state : JobState , } impl From < & UpdateIngestJobStateBody > for UpdateIngestJobStateBody { fn from (value : & UpdateIngestJobStateBody) -> Self { value . clone () } } } # [derive (Clone , Debug)] # [doc = "Client for Salesforce REST API\n\nSalesforce REST API including Bulk API v2.0 for programmatic access to\nSalesforce data and metadata operations.\n\n\nVersion: 1.0.0"] pub struct Client { pub (crate) baseurl : String , pub (crate) client : reqwest :: Client , } impl Client { # [doc = r" Create a new client."] # [doc = r""] # [doc = r" `baseurl` is the base URL provided to the internal"] # [doc = r" `reqwest::Client`, and should include a scheme and hostname,"] # [doc = r" as well as port and a path stem if applicable."] pub fn new (baseurl : & str ,) -> Self { # [cfg (not (target_arch = "wasm32"))] let client = { let dur = std :: time :: Duration :: from_secs (15) ; reqwest :: ClientBuilder :: new () . connect_timeout (dur) . timeout (dur) } ; # [cfg (target_arch = "wasm32")] let client = reqwest :: ClientBuilder :: new () ; Self :: new_with_client (baseurl , client . build () . unwrap () ,) } # [doc = r" Construct a new client with an existing `reqwest::Client`,"] # [doc = r" allowing more control over its configuration."] # [doc = r""] # [doc = r" `baseurl` is the base URL provided to the internal"] # [doc = r" `reqwest::Client`, and should include a scheme and hostname,"] # [doc = r" as well as port and a path stem if applicable."] pub fn new_with_client (baseurl : & str , client : reqwest :: Client ,) -> Self { Self { baseurl : baseurl . to_string () , client , } } # [doc = r" Get the base URL to which requests are made."] pub fn baseurl (& self) -> & String { & self . baseurl } # [doc = r" Get the internal `reqwest::Client` used to make requests."] pub fn client (& self) -> & reqwest :: Client { & self . client } # [doc = r" Get the version of this API."] # [doc = r""] # [doc = r" This string is pulled directly from the source OpenAPI"] # [doc = r" document and may be in any format the API selects."] pub fn api_version (& self) -> & 'static str { "1.0.0" } } # [allow (clippy :: all)] impl Client { # [doc = "Get All Query Jobs\n\nRetrieves information about all query jobs in the org. Results can be filtered\nby query parameters.\n\n\nSends a `GET` request to `/jobs/query`\n\nArguments:\n- `concurrency_mode`: For future use. Filter by concurrency mode (currently only parallel is supported)\n- `is_pk_chunking_enabled`: Filter jobs by whether PK chunking is enabled (applies to Bulk API jobs only)\n- `job_type`: Filter by job type\n- `query_locator`: Pagination locator. Use the value from nextRecordsUrl from the previous response.\n"] pub async fn get_all_query_jobs < 'a > (& 'a self , concurrency_mode : Option < types :: ConcurrencyMode > , is_pk_chunking_enabled : Option < bool > , job_type : Option < types :: JobType > , query_locator : Option < & 'a str >) -> Result < ResponseValue < types :: QueryJobList > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/query" , self . baseurl ,) ; let mut query = Vec :: with_capacity (4usize) ; if let Some (v) = & concurrency_mode { query . push (("concurrencyMode" , v . to_string ())) ; } if let Some (v) = & is_pk_chunking_enabled { query . push (("isPkChunkingEnabled" , v . to_string ())) ; } if let Some (v) = & job_type { query . push (("jobType" , v . to_string ())) ; } if let Some (v) = & query_locator { query . push (("queryLocator" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Create Query Job\n\nCreates a new bulk query job to asynchronously query large data sets.\nThe job uses SOQL to define the data to extract.\n\n\nSends a `POST` request to `/jobs/query`\n\n"] pub async fn create_query_job < 'a > (& 'a self , body : & 'a types :: CreateQueryJobRequest) -> Result < ResponseValue < types :: QueryJobInfo > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/query" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Query Job Information\n\nRetrieves detailed information about a specific query job including its current state\nand processing metrics.\n\n\nSends a `GET` request to `/jobs/query/{jobId}`\n\nArguments:\n- `job_id`: The unique identifier of the query job\n"] pub async fn get_query_job < 'a > (& 'a self , job_id : & 'a str) -> Result < ResponseValue < types :: QueryJobInfo > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/query/{}" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Delete Query Job\n\nDeletes a query job. Once deleted, the job cannot be retrieved.\n\n\nSends a `DELETE` request to `/jobs/query/{jobId}`\n\nArguments:\n- `job_id`: The unique identifier of the query job to delete\n"] pub async fn delete_query_job < 'a > (& 'a self , job_id : & 'a str) -> Result < ResponseValue < () > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/query/{}" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 204u16 => { Ok (ResponseValue :: empty (response)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Abort Query Job\n\nAborts a query job by changing its state to Aborted. This stops processing\nbut does not delete the job.\n\n\nSends a `PATCH` request to `/jobs/query/{jobId}`\n\nArguments:\n- `job_id`: The unique identifier of the query job to abort\n- `body`\n"] pub async fn abort_query_job < 'a > (& 'a self , job_id : & 'a str , body : & 'a types :: AbortQueryJobBody) -> Result < ResponseValue < types :: QueryJobInfo > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/query/{}" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . patch (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Query Job Results\n\nRetrieves the results of a completed query job. Results are returned in CSV format.\nFor large result sets, use pagination with the locator parameter.\n\n\nSends a `GET` request to `/jobs/query/{jobId}/results`\n\nArguments:\n- `job_id`: The unique identifier of the query job\n- `locator`: Locator value for pagination. Use the value from the Sforce-Locator header\nof the previous response to retrieve the next page of results.\n\n- `max_records`: Maximum number of records to return per request\n"] pub async fn get_query_job_results < 'a > (& 'a self , job_id : & 'a str , locator : Option < & 'a str > , max_records : Option < i64 >) -> Result < ResponseValue < ByteStream > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/query/{}/results" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; let mut query = Vec :: with_capacity (2usize) ; if let Some (v) = & locator { query . push (("locator" , v . to_string ())) ; } if let Some (v) = & max_records { query . push (("maxRecords" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { Ok (ResponseValue :: stream (response)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Parallel Results for a Query Job\n\nReturns up to five URIs in one response to use to get results for a query job in parallel.\nThe job must have the state jobComplete. Use the same API version that you used to create\nthe query, otherwise the call returns a 409 error.\n\n\nSends a `GET` request to `/jobs/query/{jobId}/resultPages`\n\nArguments:\n- `job_id`: The unique identifier of the query job\n- `locator`: Locator for pagination of result pages\n"] pub async fn get_query_job_result_pages < 'a > (& 'a self , job_id : & 'a str , locator : Option < & 'a str >) -> Result < ResponseValue < types :: QueryResultPages > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/query/{}/resultPages" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; let mut query = Vec :: with_capacity (1usize) ; if let Some (v) = & locator { query . push (("locator" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 409u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Information About All Ingest Jobs\n\nRetrieves detailed information about all ingest jobs in the org. Job records are\nreturned in an indeterminate order.\n\n\nSends a `GET` request to `/jobs/ingest`\n\nArguments:\n- `is_pk_chunking_enabled`: Filter jobs by whether PK chunking is enabled\n- `job_type`: Filter by job type\n- `query_locator`: Pagination locator from nextRecordsUrl\n"] pub async fn get_all_ingest_jobs < 'a > (& 'a self , is_pk_chunking_enabled : Option < bool > , job_type : Option < types :: JobType > , query_locator : Option < & 'a str >) -> Result < ResponseValue < types :: GetAllIngestJobsResponse > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/ingest" , self . baseurl ,) ; let mut query = Vec :: with_capacity (3usize) ; if let Some (v) = & is_pk_chunking_enabled { query . push (("isPkChunkingEnabled" , v . to_string ())) ; } if let Some (v) = & job_type { query . push (("jobType" , v . to_string ())) ; } if let Some (v) = & query_locator { query . push (("queryLocator" , v . to_string ())) ; } # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . query (& query) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Create Ingest Job\n\nCreates a new bulk ingest job to load, update, upsert, or delete large data sets.\nAfter creating the job, upload data and then close the job to begin processing.\n\n\nSends a `POST` request to `/jobs/ingest`\n\n"] pub async fn create_ingest_job < 'a > (& 'a self , body : & 'a types :: CreateIngestJobRequest) -> Result < ResponseValue < types :: IngestJobInfo > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/ingest" , self . baseurl ,) ; # [allow (unused_mut)] let mut request = self . client . post (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 403u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Ingest Job Information\n\nRetrieves detailed information about a specific ingest job including its current state\nand processing metrics.\n\n\nSends a `GET` request to `/jobs/ingest/{jobId}`\n\nArguments:\n- `job_id`: The unique identifier of the ingest job\n"] pub async fn get_ingest_job < 'a > (& 'a self , job_id : & 'a str) -> Result < ResponseValue < types :: IngestJobInfo > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/ingest/{}" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Delete Ingest Job\n\nDeletes an ingest job. The job must be in UploadComplete, JobComplete, Aborted, or Failed state.\nWhen deleted, job data and metadata are permanently removed.\n\n\nSends a `DELETE` request to `/jobs/ingest/{jobId}`\n\nArguments:\n- `job_id`: The unique identifier of the ingest job to delete\n"] pub async fn delete_ingest_job < 'a > (& 'a self , job_id : & 'a str) -> Result < ResponseValue < () > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/ingest/{}" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . delete (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 204u16 => { Ok (ResponseValue :: empty (response)) } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Update Ingest Job State\n\nUpdates the state of an ingest job. Use this to mark a job as UploadComplete\n(ready for processing) or Aborted (cancel processing).\n\n\nSends a `PATCH` request to `/jobs/ingest/{jobId}`\n\nArguments:\n- `job_id`: The unique identifier of the ingest job\n- `body`\n"] pub async fn update_ingest_job_state < 'a > (& 'a self , job_id : & 'a str , body : & 'a types :: UpdateIngestJobStateBody) -> Result < ResponseValue < types :: IngestJobInfo > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/ingest/{}" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . patch (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . json (& body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { ResponseValue :: from_response (response) . await } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Upload Job Data\n\nUploads CSV data for the ingest job. The data must not exceed 100 MB to account\nfor base64 encoding (which can increase size by ~50%).\n\n\nSends a `PUT` request to `/jobs/ingest/{jobId}/batches`\n\nArguments:\n- `job_id`: The unique identifier of the ingest job\n- `body`\n"] pub async fn upload_ingest_job_data < 'a , B : Into < reqwest :: Body > > (& 'a self , job_id : & 'a str , body : B) -> Result < ResponseValue < () > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/ingest/{}/batches" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . put (url) . header (reqwest :: header :: ACCEPT , reqwest :: header :: HeaderValue :: from_static ("application/json" ,) ,) . header (reqwest :: header :: CONTENT_TYPE , reqwest :: header :: HeaderValue :: from_static ("application/octet-stream") ,) . body (body) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 201u16 => { Ok (ResponseValue :: empty (response)) } 400u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Job Successful Record Results\n\nRetrieves a CSV file containing all successfully processed records for a completed job.\n\n\nSends a `GET` request to `/jobs/ingest/{jobId}/successfulResults`\n\nArguments:\n- `job_id`: The unique identifier of the ingest job\n"] pub async fn get_ingest_job_successful_results < 'a > (& 'a self , job_id : & 'a str) -> Result < ResponseValue < ByteStream > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/ingest/{}/successfulResults" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { Ok (ResponseValue :: stream (response)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Job Failed Record Results\n\nRetrieves a CSV file containing all failed records with error information for a completed job.\n\n\nSends a `GET` request to `/jobs/ingest/{jobId}/failedResults`\n\nArguments:\n- `job_id`: The unique identifier of the ingest job\n"] pub async fn get_ingest_job_failed_results < 'a > (& 'a self , job_id : & 'a str) -> Result < ResponseValue < ByteStream > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/ingest/{}/failedResults" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { Ok (ResponseValue :: stream (response)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } # [doc = "Get Job Unprocessed Record Results\n\nRetrieves a CSV file containing all unprocessed records for failed or aborted jobs.\n\n\nSends a `GET` request to `/jobs/ingest/{jobId}/unprocessedrecords`\n\nArguments:\n- `job_id`: The unique identifier of the ingest job\n"] pub async fn get_ingest_job_unprocessed_results < 'a > (& 'a self , job_id : & 'a str) -> Result < ResponseValue < ByteStream > , Error < types :: ErrorResponse > , > { let url = format ! ("{}/jobs/ingest/{}/unprocessedrecords" , self . baseurl , encode_path (& job_id . to_string ()) ,) ; # [allow (unused_mut)] let mut request = self . client . get (url) . build () ? ; let result = self . client . execute (request) . await ; let response = result ? ; match response . status () . as_u16 () { 200u16 => { Ok (ResponseValue :: stream (response)) } 401u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } 404u16 => { Err (Error :: ErrorResponse (ResponseValue :: from_response (response) . await ?)) } _ => Err (Error :: UnexpectedResponse (response)) , } } } # [doc = r" Items consumers will typically use such as the Client."] pub mod prelude { # [allow (unused_imports)] pub use super :: Client ; }